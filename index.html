<!DOCTYPE html>

<html>

<head>
  <meta charset="utf-8">
  <title>Reversi</title>
  <style>
    body {
      background-color: darkslategray;
    }

    .control-container {
      display: flex;
      flex-flow: row wrap;
      justify-content: center;
      align-items: center;
      row-gap: 15px;
      column-gap: 25px;
    }

    .button-container {
      display: flex;
      flex-flow: row nowrap;
      align-items: center;
      column-gap: 15px;
    }

    .button-container button {
      font-family: sans-serif;
    }

    .select-container {
      display: flex;
      flex-flow: row wrap;
      align-items: center;
      row-gap: 15px;
      column-gap: 15px;
    }

    .select-sub-container {
      display: flex;
      flex-flow: row nowrap;
      align-items: center;
      column-gap: 10px;
    }

    .select-sub-container label {
      color: white;
      font-family: sans-serif;
    }

    .chessboard-container {
      max-width: 90vmin;
      max-height: 90vmin;
      aspect-ratio: 1;
      margin: 15px auto 0px auto;
      padding: 0px;
    }

    #chessboard-table {
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border: 4px solid black;
      border-collapse: collapse;
      margin: 0px;
      padding: 0px;
      box-shadow: 0px 0px 8px black;
    }

    #chessboard-table tr {
      width: 100%;
      height: 12.5%;
      border: none;
      margin: 0px;
      padding: 0px;
    }

    #chessboard-table td {
      box-sizing: border-box;
      width: 12.5%;
      height: 12.5%;
      border: 2px solid black;
      margin: 0px;
      padding: 0px;
      background-color: mediumseagreen;
    }

    .disc {
      width: 80%;
      height: 80%;
      border-radius: 50%;
      margin: auto;
      padding: 0px;
      box-shadow: 0px 0px 4px black;
      transition-property: width, height, opacity, background-color, box-shadow;
      transition-duration: 1s;
    }

    .disc.first {
      background-color: black;
    }

    .disc.second {
      background-color: white;
    }

    .disc.tentative {
      width: 40%;
      height: 40%;
      opacity: 0.5;
      box-shadow: none;
    }

    .disc.invisible {
      opacity: 0;
    }
  </style>
</head>

<body>
  <div class="control-container">
    <div class="button-container">
      <button id="start-button">Start</button>
      <button id="end-button" disabled>End</button>
      <button id="undo-button" disabled>Undo</button>
    </div>
    <div class="select-container">
      <div class="select-sub-container">
        <label for="first-player-select">First player:</label>
        <select id="first-player-select">
          <option value="human">Human</option>
          <option value="agent">Agent</option>
        </select>
      </div>
      <div class="select-sub-container">
        <label for="second-player-select">Second player:</label>
        <select id="second-player-select">
          <option value="human">Human</option>
          <option value="agent">Agent</option>
        </select>
      </div>
    </div>
  </div>

  <div class="chessboard-container">
    <table id="chessboard-table"></table>
  </div>

  <script>
    const startButton = document.querySelector("#start-button");
    const endButton = document.querySelector("#end-button");
    const undoButton = document.querySelector("#undo-button");

    const firstPlayerSelect = document.querySelector("#first-player-select");
    const secondPlayerSelect = document.querySelector("#second-player-select");

    const chessboardTable = document.querySelector("#chessboard-table");
    const chessboardClickCallbacks = [];

    function initChessboardTable() {
      function handleClick(row, col) {
        for (let i = 0; i < chessboardClickCallbacks.length;) {
          if (chessboardClickCallbacks[i](row, col)) {
            chessboardClickCallbacks.splice(i, 1);
          } else {
            ++i;
          }
        }
      }

      chessboardTable.innerHTML = "";
      for (let row = 0; row < 8; ++row) {
        const tableRow = document.createElement("tr");
        for (let col = 0; col < 8; ++col) {
          const disc = document.createElement("div");
          disc.className = "disc invisible tentative";
          const tableCell = document.createElement("td");
          tableCell.addEventListener("click", () => handleClick(row, col));
          tableCell.appendChild(disc);
          tableRow.appendChild(tableCell);
        }
        chessboardTable.appendChild(tableRow);
      }
    }

    initChessboardTable();

    async function updateChessboardTable({ currentPlayer, chessboardData, scoresOfMoves }) {
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          const disc = chessboardTable.rows[row].cells[col].querySelector(".disc");
          switch (chessboardData[row][col]) {
            case +1:
              disc.className = "disc first";
              break;
            case -1:
              disc.className = "disc second";
              break;
            default:
              if (!scoresOfMoves[row][col]) {
                disc.className = "disc invisible tentative";
              } else {
                switch (currentPlayer) {
                  case +1:
                    disc.className = "disc tentative first";
                    break;
                  case -1:
                    disc.className = "disc tentative second";
                    break;
                }
              }
          }
        }
      }
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    function getScoresOfMoves(player, chessboardData) {
      const scores = new Array(8);
      for (let row = 0; row < 8; ++row) {
        scores[row] = new Array(8).fill(0);
      }

      function createScoreUpdater() {
        let state = 0;
        let score = 0;
        return (row, col) => {
          const squareValue = chessboardData[row][col];
          switch (state) {
            case 0:
              if (squareValue === player) {
                state = 1;
              }
              break;
            case 1:
              if (squareValue === 0) {
                state = 0;
              } else if (squareValue === -player) {
                state = 2;
                score = 1;
              }
              break;
            case 2:
              switch (squareValue) {
                case +player:
                  state = 1;
                  score = 0;
                  break;
                case -player:
                  ++score;
                  break;
                default:
                  scores[row][col] += score;
                  state = 0;
                  score = 0;
              }
              break;
          }
        };
      }

      for (let i = 0; i < 8; ++i) {
        const fwdRowUpdater = createScoreUpdater();
        const fwdColUpdater = createScoreUpdater();
        const bwdRowUpdater = createScoreUpdater();
        const bwdColUpdater = createScoreUpdater();
        for (let j = 0; j < 8; ++j) {
          fwdRowUpdater(i, j);
          fwdColUpdater(j, i);
          bwdRowUpdater(i, 7 - j);
          bwdColUpdater(7 - j, i);
        }
      }
      {
        const fwdMainUpdater = createScoreUpdater();
        const fwdAntiUpdater = createScoreUpdater();
        const bwdMainUpdater = createScoreUpdater();
        const bwdAntiUpdater = createScoreUpdater();
        for (let i = 0; i < 8; ++i) {
          fwdMainUpdater(i, i);
          fwdAntiUpdater(i, 7 - i);
          bwdMainUpdater(7 - i, 7 - i);
          bwdAntiUpdater(7 - i, i);
        }
      }
      for (let i = 1; i < 6; ++i) {
        const fwdMainLowerUpdater = createScoreUpdater();
        const fwdMainUpperUpdater = createScoreUpdater();
        const fwdAntiLowerUpdater = createScoreUpdater();
        const fwdAntiUpperUpdater = createScoreUpdater();
        const bwdMainLowerUpdater = createScoreUpdater();
        const bwdMainUpperUpdater = createScoreUpdater();
        const bwdAntiLowerUpdater = createScoreUpdater();
        const bwdAntiUpperUpdater = createScoreUpdater();
        for (let j = i, k = 0; j < 8; ++j, ++k) {
          fwdMainLowerUpdater(j, k);
          fwdMainUpperUpdater(k, j);
          fwdAntiLowerUpdater(j, 7 - k);
          fwdAntiUpperUpdater(k, 7 - j);
          bwdMainLowerUpdater(7 - k, 7 - j);
          bwdMainUpperUpdater(7 - j, 7 - k);
          bwdAntiLowerUpdater(7 - k, j);
          bwdAntiUpperUpdater(7 - j, k);
        }
      }

      return scores;
    }

    function hasLegalMove(scoresOfMoves) {
      for (const scoreRow of scoresOfMoves) {
        for (const score of scoreRow) {
          if (score) {
            return true;
          }
        }
      }
      return false;
    }

    function makeMove(currentPlayer, chessboardData, move) {
      const newChessboardData = new Array(8);
      for (let row = 0; row < 8; ++row) {
        newChessboardData[row] = [...chessboardData[row]];
      }
      newChessboardData[move[0]][move[1]] = currentPlayer;

      function flipDiscsInDirection(rowStep, colStep) {
        let [row, col] = move;
        do {
          row += rowStep;
          col += colStep;
          if (!(0 <= row && row < 8) || !(0 <= col && col < 8) || chessboardData[row][col] === 0) {
            return;
          }
        } while (chessboardData[row][col] !== currentPlayer);
        while (row -= rowStep, col -= colStep, row !== move[0] || col !== move[1]) {
          newChessboardData[row][col] = -chessboardData[row][col];
        }
      }

      flipDiscsInDirection(+1, 0);
      flipDiscsInDirection(-1, 0);
      flipDiscsInDirection(0, +1);
      flipDiscsInDirection(0, -1);
      flipDiscsInDirection(+1, +1);
      flipDiscsInDirection(+1, -1);
      flipDiscsInDirection(-1, +1);
      flipDiscsInDirection(-1, -1);
      return newChessboardData;
    }

    class Game {
      constructor(firstPlayer, secondPlayer) {
        startButton.disabled = true;
        firstPlayerSelect.disabled = true;
        secondPlayerSelect.disabled = true;

        this.firstPlayer = firstPlayer;
        this.secondPlayer = secondPlayer;
        this.endFlag = false;
        this.undoFlag = false;
        this.stateHistory = [];

        const chessboardData = new Array(8);
        for (let row = 0; row < 8; ++row) {
          chessboardData[row] = new Array(8).fill(0);
        }
        const currentPlayer = +1;
        chessboardData[3][4] = +1;
        chessboardData[4][3] = +1;
        chessboardData[3][3] = -1;
        chessboardData[4][4] = -1;
        this.state = {
          currentPlayer,
          chessboardData,
          scoresOfMoves: getScoresOfMoves(currentPlayer, chessboardData),
        }

        endButton.disabled = false;
      }

      waitForEndOrUndoClick() {
        this.endFlag = false;
        this.undoFlag = false;
        const self = this;
        return new Promise(resolve => {
          endButton.onclick = () => {
            endButton.onclick = () => { };
            undoButton.onclick = () => { };
            self.endFlag = true;
            resolve();
          }
          undoButton.onclick = () => {
            endButton.onclick = () => { };
            undoButton.onclick = () => { };
            self.undoFlag = true;
            resolve();
          }
        });
      }

      async undo() {
        if (this.stateHistory.length === 1) {
          undoButton.disabled = true;
        }
        this.state = this.stateHistory.pop();
        await updateChessboardTable(this.state);
      }

      async end() {
        endButton.disabled = true;
        undoButton.disabled = true;

        const zeroMatrix = new Array(8);
        for (let row = 0; row < 8; ++row) {
          zeroMatrix[row] = new Array(8).fill(0);
        }
        await updateChessboardTable({
          currentPlayer: +1,
          chessboardData: zeroMatrix,
          scoresOfMoves: zeroMatrix,
        });

        startButton.disabled = false;
        firstPlayerSelect.disabled = false;
        secondPlayerSelect.disabled = false;
      }

      async run() {
        await Promise.any([updateChessboardTable(this.state), this.waitForEndOrUndoClick()]);
        if (this.endFlag) {
          this.end();
          return;
        }

        while (true) {
          if (!hasLegalMove(this.state.scoresOfMoves)) {
            const nextScoresOfMoves = getScoresOfMoves(-this.state.currentPlayer, this.state.chessboardData);
            if (!hasLegalMove(nextScoresOfMoves)) {
              break;
            }
            alert((this.state.currentPlayer > 0 ? "Black" : "White") + " is out of move");
            this.state = {
              currentPlayer: -this.state.currentPlayer,
              chessboardData: this.state.chessboardData,
              scoresOfMoves: nextScoresOfMoves,
            };
          } else {
            const player = this.state.currentPlayer > 0 ? this.firstPlayer : this.secondPlayer;
            const move = await Promise.any([player.play(this.state), this.waitForEndOrUndoClick()]);
            if (this.endFlag) {
              this.end();
              return;
            }
            if (this.undoFlag) {
              await this.undo();
              continue;
            }
            if (player.undoable) {
              this.stateHistory.push(this.state);
              undoButton.disabled = false;
            }
            const nextChessboardData = makeMove(this.state.currentPlayer, this.state.chessboardData, move);
            this.state = {
              currentPlayer: -this.state.currentPlayer,
              chessboardData: nextChessboardData,
              scoresOfMoves: getScoresOfMoves(-this.state.currentPlayer, nextChessboardData),
            };
          }

          await Promise.any([updateChessboardTable(this.state), this.waitForEndOrUndoClick()]);
          if (this.endFlag) {
            this.end();
            return;
          }
          if (this.undoFlag) {
            await this.undo();
            continue;
          }
        }

        let firstCount = 0, secondCount = 0;
        for (const squareRow of this.state.chessboardData) {
          for (const squareValue of squareRow) {
            switch (squareValue) {
              case +1:
                ++firstCount;
                break;
              case -1:
                ++secondCount;
                break;
            }
          }
        }
        let winnerMessage = null;
        if (firstCount > secondCount) {
          winnerMessage = "Black is the winner.";
        } else if (firstCount < secondCount) {
          winnerMessage = "White is the winner.";
        } else {
          winnerMessage = "The game is a tie.";
        }
        alert("Game over! " + winnerMessage);

        undoButton.disabled = true;
        while (true) {
          await this.waitForEndOrUndoClick();
          if (this.endFlag) {
            this.end();
            return;
          }
        }
      }
    }

    const humanPlayer = {
      undoable: true,
      play: ({ currentPlayer, chessboardData, scoresOfMoves }) => {
        return new Promise(resolve => {
          chessboardClickCallbacks.push((row, col) => {
            if (scoresOfMoves[row][col]) {
              resolve([row, col]);
              return true;
            } else {
              return false;
            }
          });
        });
      },
    };

    function getHeuristic(chessboardData) {
      let firstCount = 0, secondCount = 0;
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          switch (chessboardData[row][col]) {
            case +1:
              ++firstCount;
              break;
            case -1:
              ++secondCount;
              break;
          }
        }
      }
      const coinParityScore = (firstCount - secondCount) / (firstCount + secondCount);

      const firstScoresOfMoves = getScoresOfMoves(+1, chessboardData);
      const secondScoresOfMoves = getScoresOfMoves(-1, chessboardData);
      let firstActualMobility = 0, secondActualMobility = 0;
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          if (firstScoresOfMoves[row][col] > 0) {
            ++firstActualMobility;
          }
          if (secondScoresOfMoves[row][col] > 0) {
            ++secondActualMobility;
          }
        }
      }
      const actualMobilityScore = firstActualMobility === 0 && secondActualMobility === 0 ? 0 :
        (firstActualMobility - secondActualMobility) / (firstActualMobility + secondActualMobility);

      const firstPotentialMoves = new Array(8), secondPotentialMoves = new Array(8);
      for (let row = 0; row < 8; ++row) {
        firstPotentialMoves[row] = new Array(8).fill(false);
        secondPotentialMoves[row] = new Array(8).fill(false);
      }
      function updatePotentialMoves(row, col, adjRow, adjCol) {
        if (!(0 <= adjRow && adjRow < 8) || !(0 <= adjCol && adjCol < 8)) {
          return;
        }
        switch (chessboardData[adjRow][adjCol]) {
          case +1:
            secondPotentialMoves[row][col] = true;
            break;
          case -1:
            firstPotentialMoves[row][col] = true;
            break;
        }
      }
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          if (chessboardData[row][col] !== 0) {
            continue;
          }
          updatePotentialMoves(row, col, row + 1, col);
          updatePotentialMoves(row, col, row - 1, col);
          updatePotentialMoves(row, col, row, col + 1);
          updatePotentialMoves(row, col, row, col - 1);
          updatePotentialMoves(row, col, row + 1, col + 1);
          updatePotentialMoves(row, col, row + 1, col - 1);
          updatePotentialMoves(row, col, row - 1, col + 1);
          updatePotentialMoves(row, col, row - 1, col - 1);
        }
      }
      let firstPotentialMobility = 0, secondPotentialMobility = 0;
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          if (firstPotentialMoves[row][col]) {
            ++firstPotentialMobility;
          }
          if (secondPotentialMoves[row][col]) {
            ++secondPotentialMobility;
          }
        }
      }
      const potentialMobilityScore = firstPotentialMobility === 0 && secondActualMobility === 0 ? 0 :
        (firstPotentialMobility - secondPotentialMobility) / (firstPotentialMobility + secondPotentialMobility);

      let firstCornerScore = 0, secondCornerScore = 0;
      for (const [row, col] of [[0, 0], [0, 7], [7, 0], [7, 7]]) {
        switch (chessboardData[row][col]) {
          case +1:
            firstCornerScore += 2;
            break;
          case -1:
            secondCornerScore += 2;
            break;
          default:
            if (firstScoresOfMoves[row][col] > 0) {
              ++firstCornerScore;
            }
            if (secondScoresOfMoves[row][col] > 0) {
              ++secondCornerScore;
            }
        }
      }
      const cornerScore = firstCornerScore === 0 && secondCornerScore === 0 ? 0 :
        (firstCornerScore - secondCornerScore) / (firstCornerScore + secondCornerScore);

      const stabilityWeights = [
        [+4, -3, +2, +2, +2, +2, -3, +4],
        [-3, -4, -1, -1, -1, -1, -4, -3],
        [+2, -1, +1, +0, +0, +1, -1, +2],
        [+2, -1, +0, +1, +1, +0, -1, +2],
        [+2, -1, +0, +1, +1, +0, -1, +2],
        [+2, -1, +1, +0, +0, +1, -1, +2],
        [-3, -4, -1, -1, -1, -1, -4, -3],
        [+4, -3, +2, +2, +2, +2, -3, +4],
      ];
      let firstStabilityScore = 0, secondStabilityScore = 0;
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          switch (chessboardData[row][col]) {
            case +1:
              firstStabilityScore += stabilityWeights[row][col];
              break;
            case -1:
              secondStabilityScore += stabilityWeights[row][col];
              break;
          }
        }
      }
      const stabilityScore = (firstStabilityScore - secondCornerScore) / 50;

      return cornerScore * 18 +
        actualMobilityScore * 2 +
        potentialMobilityScore +
        stabilityScore * 15 +
        coinParityScore * 15;
    }

    function getSortedLegalMoves(scoresOfMoves) {
      const scoredMoves = [];
      for (let row = 0; row < 8; ++row) {
        for (let col = 0; col < 8; ++col) {
          const score = scoresOfMoves[row][col];
          if (score > 0) {
            scoredMoves.push([score, [row, col]]);
          }
        }
      }
      return scoredMoves.sort((a, b) => b[0] - a[0]).map(x => x[1]);
    }

    function alphaBetaSearch({ currentPlayer, chessboardData, scoresOfMoves }, depth, alpha, beta) {
      if (depth === 0) {
        return getHeuristic(chessboardData);
      }
      const legalMoves = getSortedLegalMoves(scoresOfMoves);
      if (legalMoves.length === 0) {
        const nextScoresOfMoves = getScoresOfMoves(-currentPlayer, chessboardData);
        if (!hasLegalMove(nextScoresOfMoves)) {
          return getHeuristic(chessboardData);
        }
        return alphaBetaSearch({
          currentPlayer: -currentPlayer,
          chessboardData: chessboardData,
          scoresOfMoves: nextScoresOfMoves,
        }, depth - 1, alpha, beta);
      }
      if (currentPlayer > 0) {
        let bestScore = Number.NEGATIVE_INFINITY;
        for (const move of legalMoves) {
          const nextChessboardData = makeMove(currentPlayer, chessboardData, move);
          const score = alphaBetaSearch({
            currentPlayer: -currentPlayer,
            chessboardData: nextChessboardData,
            scoresOfMoves: getScoresOfMoves(-currentPlayer, nextChessboardData),
          }, depth - 1, alpha, beta);
          bestScore = Math.max(bestScore, score);
          alpha = Math.max(alpha, score);
          if (score >= beta) {
            break;
          }
        }
        return bestScore;
      } else {
        let bestScore = Number.POSITIVE_INFINITY;
        for (const move of legalMoves) {
          const nextChessboardData = makeMove(currentPlayer, chessboardData, move);
          const score = alphaBetaSearch({
            currentPlayer: -currentPlayer,
            chessboardData: nextChessboardData,
            scoresOfMoves: getScoresOfMoves(-currentPlayer, nextChessboardData),
          }, depth - 1, alpha, beta);
          bestScore = Math.min(bestScore, score);
          beta = Math.min(beta, score);
          if (score <= alpha) {
            break;
          }
        }
        return bestScore;
      }
    }

    const agentPlayer = {
      unduable: false,
      play: ({ currentPlayer, chessboardData, scoresOfMoves }) => {
        const depth = 8;
        let alpha = Number.NEGATIVE_INFINITY, beta = Number.POSITIVE_INFINITY;
        const legalMoves = getSortedLegalMoves(scoresOfMoves);
        if (currentPlayer > 0) {
          let bestScore = Number.NEGATIVE_INFINITY;
          let bestMove = null;
          for (const move of legalMoves) {
            const nextChessboardData = makeMove(currentPlayer, chessboardData, move);
            const score = alphaBetaSearch({
              currentPlayer: -currentPlayer,
              chessboardData: nextChessboardData,
              scoresOfMoves: getScoresOfMoves(-currentPlayer, nextChessboardData),
            }, depth - 1, alpha, beta);
            if (score > bestScore) {
              bestScore = score;
              bestMove = move;
            }
            alpha = Math.max(alpha, score);
          }
          return bestMove;
        } else {
          let bestScore = Number.POSITIVE_INFINITY;
          let bestMove = null;
          for (const move of legalMoves) {
            const nextChessboardData = makeMove(currentPlayer, chessboardData, move);
            const score = alphaBetaSearch({
              currentPlayer: -currentPlayer,
              chessboardData: nextChessboardData,
              scoresOfMoves: getScoresOfMoves(-currentPlayer, nextChessboardData),
            }, depth - 1, alpha, beta);
            if (score < bestScore) {
              bestScore = score;
              bestMove = move;
            }
            beta = Math.min(beta, score);
          }
          return bestMove;
        }
      },
    };

    startButton.onclick = async () => {
      let firstPlayer = null;
      if (firstPlayerSelect.value === "agent") {
        firstPlayer = agentPlayer;
      } else {
        firstPlayer = humanPlayer;
      }

      let secondPlayer = null;
      if (secondPlayerSelect.value === "agent") {
        secondPlayer = agentPlayer;
      } else {
        secondPlayer = humanPlayer;
      }

      await new Game(firstPlayer, secondPlayer).run();
    };
  </script>
</body>

</html>